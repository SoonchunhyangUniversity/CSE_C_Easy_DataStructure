/*
    1. 다음 중 추상 데이터 타입에 대한 설명 중 틀린 것은?           답 : (3)
        (1) 추상 데이터 타입은  구현의 세부적인 사항을 무시한다.
        (2) 자료 구조의 구현이 바뀌더라도 추상 데이터 타입의 연산만을 사용하였다면 응용 프로그램을 바꾸지 않아도 된다.
        (3) 추상 데이터 타입을 사용하면 프로그램의 실행 속도가 빨라진다.
        (4) 자세하고 명확한 인터페이스를 사용함으로써 요류의 가능성을 줄인다.

    2. Set(집합) 추상 데이터 타입을 정의하라. 다음과 같은 연산자들을 포함시켜라.
        Create, Insert, Remove, Is_In, Union, Intersection, Difference

        ADT Set
        객채 정의 : 집합은 원소라 불리는 데이터 요소들의 모임
        연산 정의 : Create() := 집합을 생성하여 반환한다.
                    Insert(S, item) := 원소 item을 집합 S에 저장한다.
                    Remove(S, item) := 원소 item을 집합 S에서 삭제한다.
                    Is_In(S, item) := 집합 S에 item이 있는지를 검사한다.
                    Union(S1, S1) := S1과 S2의 합집합을 구한다.
                    Intersection(S1, S2) := S1과 S2의 교집합을 구한다.
                    Difference(S1, S2) := S1과 S2의 차집합을 구한다.

    3. Boolean 추상 데이터 타입을 정의하고 다음과 같은 연산자들을 포함시켜라.
        And, Or, Not, Xor

        ADT Boolean
        객채 정의 : 0과 1
        연산 정의 : And(b1, b2) := if b1 = 1 and b2 = 1 then return 1;
                                   else return 0;
                    Or(b1, b2) := if b1=0 and b2=0 then return 0
               		               else return 1;
                    Not(b) := if b=0 return 1;
               		          else return 0;
                    Xor(b1, b2) := if (b1=1 and b2=1) or (b1=0 and b2=0) then return 0;
               		               else return 1;

    4. 시간 복잡도 함수 n² + 10n + 8을 빅오 표기법으로 나타내면?   답 : (3)
        (1) O(n)    (2) O(nlogn)   (3) O(n²)   (4) O(n²logn)

    5. 시간 복잡도의 함수가 7n + 10이라면 이것이 나타내는 것은 무엇인가?     답 : (1)
        (1) 연산의 횟수
        (2) 프로그램의 컴파일 시간
        (3) 프로그램이 차지하는 메모리의 양
        (4) 입력 데이터의 총 개수

    6. O(n²)의 시간 복잡도를 가지는 알고리즘에서 입력의 개수가 2배로 되었다면 실행 시간은 어떻게 되는가?   답 : (3)
        (1) 변함없다    (2) 2배  (3) 4배  (4) 8배

    7. O(n²)의 시간 복잡도를 가지는 알고리즘이 1개의 입력을 1초에 처리한다. 이 알고리즘이 10개의 입력을 처리하는 대략적인 시간은?
                10 * 10 = 100

    8. 다음의 빅오 표기법들을 실행 시간이 적게 걸리는 것부터 나열하라.
        O(1)    O(n)   O(log n)      O(n²)    O(n log n)    O(n!)   O(2ⁿ)

        O(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(2ⁿ) < O(n!)

    9. 다음의 코드에서 대입 연산, 곱셈 연산, 덧셈 연산, 비교 연산의 개수를 계산하여 시간 복잡도 함수를 계산해보라.
        (1) test(int n)                         (2) float sum(float list[], int n)
            {                                       {
                int i;                                  float tempsum;
                int total = 1;                          int i;
                for(i = 2; i < n; i++)                  tempsum = 0;
                {                                       for(i = 0; i < n; i++)
                    total *= n;                         {
                }                                           tempsum += list[i];
                return n;                               }
            }                                           tempsum += 100;
                                                        tempsum += 200;
        (3) void sum(int n)                             return tempsum;
            {
                int i, b;                                (1) 1번의 대입연산 n - 2번의 곱셈과 대입연산
                b = 2;                                       1 + n - 2 + n - 2번의 연산 -> O(n)
                i = 1;                                   (2) 1번의 대입연산 n번의 대입연산, 덧셈연산
                while(i <= n)                                1번의 대입연산, 덧셉연산 * 2
                {                                            1 + n + n + 2 + n -> O(n)
                    i = i * b;                           (3) 1번의 대입연산 * 2, logn번의 곱셈, 대입연산
                }                                            1 + 1 + logn + logn -> O(logn)
            }

    10. 두 개의 알고리즘 A와 B가 있다. A의 시간 복잡도 함수는 1000n² + 1000이고 B의 시간 복잡도 함수는 2ⁿ이라고 하자.
        n의 값이 어느정도 이상이어야 A가 유리한가?
                n >= 19 이면 1000n² + 1000 <= 2ⁿ
    11. 두 함수 30n + 4와 n²를 여러 가지 n 값으로 비교하라. 어느 구간에서 30n +4가 n²보다 적은 값을 갖는지 구하라.
        그래프를 그려보라.
                n >= 31 이면 30n + 4 < n²
    12. a,b > 1인 경우에 O(loga n) = O(logb n)임을 증명하라.
                loga n = log b n / log b a = 1 / log b a * log b n = c * log b n
                따라서 O(loga n) = O(logb n)

    13. 다음은 실제로 프로그램의 실행 시간을 측정하여 도표로 나타낸 것이다. 도표로부터 이 프로그램의 시간 복잡도를
        예측하여 빅오표기법으로 나타내라.
                입력의 개수 n                  실행시간(초)
                    2                               2
                    4                               8
                    8                               25
                    16                              63
                    32                              162
                정답 : O(nlogn)

    14. 다음 프로그램의 시간 복잡도를 빅오 표기법으로 나타내라.
        (1) for( i = 0; i < n; ++i) ++k;                O(n)
        (2) for( i = 1; i < n; i *=2) ++k;              O(logn)
        (3) for( i = n - 1; i != 0; i /= 2) ++k;        O(logn)
        (4) for( i = 0; i < n; ++i)
                if( i % 2 == 0) ++k;                    O(n)
        (5) for( i = 0; i < n;  ++i)
                for( j = 0; j < n; ++j) ++k;            O(n²)
        (6) for( i = 0; i < n; ++i)
                for( j = 1; j < n; ++j) ++k;            O(n²)
        (7) for( i = 0; i < n; ++i)
                for( j = 0; j < n; ++j)
                    for( r = 0; r < 10; ++r) ++k;       O(n²)

    15. sub 함수의 시간 복잡도가 O(n)일 때 다음 문장의 시간 복잡도는?
        for(i = 1; i < n; i *= 2)
            sub();                          O(nlogn)

    16. 빅오 표기법의 정의를 사용하여 다음을 증명하라.
        (1) 5n² + 3 = O(n²)                     n >= 1 , 5n² + 3 <= 1000n² 이므로 O(n²)
        (2) 3n² + 10n = O(n²)                   n >= 1 , 3n² + 10n <= 1000n² 이므로 O(n²)
        (3) 7n³ + 10n² - 3n + 5 = O(n³)         n >= 1 , 7n³ + 10n² - 3n + 5 <= 1000n² 이므로 O(n²)
        (4) 5n² + 2ⁿ = O(2ⁿ)                  n >= 1 , 5n² + 2ⁿ <= 1000 * 2ⁿ 이므로 O(2ⁿ)

    17. 빅오 표기법의 정의를 이용하여 6n² + 3n이 O(n)이 될 수 없음을 보여라.
            n > n0 일때 6n² + 3n < c * n 을 만족하는 n0와 c를 찾을 수 없다.

    18. 다음의 프로그램 코드에 대하여 답하라.
        int i, k;
        for(i = 0; i < (n - 2); i++)
            for(k = 0; k < 30; k++)
                buffer[i][k] = 0;

        (1) 다음 알고리즘의 시간 복잡도를 n에 대한 함수로 나타내고, 빅오 표기법으로도 나타내어라.
            여기서 입력의 개수는 양의 정수 n이다.          O(n)
        (2) 위의 프로그램에서 입력의 개수도 100배 증가하였고 CPU의 속도도 100배 증가하였을 경우,
            위의 프로그램의 실행 시간이 늘어나는가? 아니면 줄어드는가? 그 이유는?
                O(n)이므로 수행속도는 입력에 정비례한다. 따라서 수행시간은 변함이 없다.

    19. 다음 알고리즘의 시간 복잡도를 n에 대한 함수로 나타내고, 빅오 표기법으로 나타내라.
        answer = 1.0;                                   1번
        temp = a;                                       1번
        k = n;                                          1번
        while(k > 0)                                    루프제어문장 무시
        {
            if((k % 2) != 0) answer *= temp;            logn번의 비교연산, 곱셈, 대입연산
            k = (int) k / 2;                            1번
        }                                               O(logn)

    20. 배열에 정수가 들어 있다고 가정하고 다음 작업의 최악, 최선의 시간 복잡도를 빅오 표기법으로 말하라.
        (1) 배열의 n 번째 숫자를 화면에 출력한다.      최악 O(1) 최선 O(1)
        (2) 배열 안의 숫자 중에서 최솟값을 찾는다.     최악 O(n) 최선 O(n)
        (3) 배열의 모든 숫자를 더한다.                 최악 O(n) 최선 O(n)

    21. (1) 크기가 n인 배열 array에서 임의의 위치 loc에 정수 value를 삽입하는 함수를 작성하라.
            정수가 삽입되면 그 뒤에 있는 정수들은 한 칸씩 뒤로 밀려야한다. 현재 배열에 들어 있는 원소의
            개수는 items개라고 하자.(여기서 items << n라고 가정)
            void insert_array(int loc, int value)
            {
        		int i;
        		for(i=items-1; i>=loc;i--)
        			array[i+1] = array[i];	 items-loc개의 대입연산
        		array[loc] = value;		     1개의 대입연산
        		items++;			         1개의 산술연산
	        }
        (2) 위의 연산의 최악, 최선, 평균적인 경우의 시간 복잡도는? (빅오 표기법으로)
                최선의 시간복잡도: 배열의 마지막에 삽입 = O(1)
                최악의 시간복잡도: 배열의 처음에 삽입 = O(n)
                평균적인 시간복잡도: (2+3+4+...+(items+2))/items=O(items) = O(n)

    22. C언어의 typedef을 이용하여 complex라고 하는 새로운 데이터 타입을 정의하라.
        complex 데이터 타입은 구조체로서 float형인 real 변수와 역시 float형인 imaginary 변수를 갖는다.
        typedef struct
        {
            float real;
            float imaginary;
        } complex;

*/
